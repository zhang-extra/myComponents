"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _keys = require("./constant/keys");

var _list = _interopRequireDefault(require("./constant/list"));

var _blocks = _interopRequireDefault(require("markup-it/lib/constants/blocks"));

var _marks = _interopRequireDefault(require("markup-it/lib/constants/marks"));

var _inlines = _interopRequireDefault(require("markup-it/lib/constants/inlines"));

var _onEnter = _interopRequireDefault(require("./handler/onEnter"));

var _blockquote = _interopRequireDefault(require("./match/blockquote"));

var _codeBlock = _interopRequireDefault(require("./match/codeBlock"));

var _code = _interopRequireDefault(require("./match/code"));

var _header = _interopRequireDefault(require("./match/header"));

var _bold = _interopRequireDefault(require("./match/bold"));

var _italic = _interopRequireDefault(require("./match/italic"));

var _strikethrough = _interopRequireDefault(require("./match/strikethrough"));

var _boldItalic = _interopRequireDefault(require("./match/boldItalic"));

var _hr = _interopRequireDefault(require("./match/hr"));

var _image = _interopRequireDefault(require("./match/image"));

var _link = _interopRequireDefault(require("./match/link"));

var _list2 = _interopRequireDefault(require("./match/list"));

var _slateEditCode = _interopRequireDefault(require("slate-edit-code"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// constant
// handler
// match
// plugins
var codePlugin = (0, _slateEditCode.default)({
  onlyIn: function onlyIn(node) {
    return node.type === "code_block";
  }
});

var checkPatterns = function checkPatterns(options, change) {
  var value = change.value;
  var texts = value.texts;
  var currentTextNode = texts.get(0);
  var currentLineText = currentTextNode.text;
  var matched; // if is in code block ignore matched patterns

  if (codePlugin.utils.isInCodeBlock(value)) {
    return;
  } // reference: https://github.com/PrismJS/prism/blob/gh-pages/components/prism-markdown.js
  // blocks


  if (matched = currentLineText.match(/^>\s/m)) {
    // [blockquote] punctuation, blockquote
    return (0, _blockquote.default)(options.blocks.BLOCKQUOTE, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/^(?: {4}|\t)/m)) {
    // [Code Block] Prefixed by 4 spaces or 1 tab
    return (0, _codeBlock.default)(options.codeOption, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/^\s*```(\w+)?\s/m)) {
    // [Code block]
    // ```lang
    return (0, _codeBlock.default)(options.codeOption, currentTextNode, matched, change, matched[1]);
  } else if (matched = currentLineText.match(/(^\s*)#{1,6}\s/m)) {
    // [Header] h1 ~ h6
    // # h1
    // ## h2
    // ###### h6
    return (0, _header.default)(options.blocks, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/(^\s*)([*-])(?:[\t ]*\2){2,}/m)) {
    // [HR]
    // ***
    // ---
    // * * *
    // -----------
    return (0, _hr.default)(options.blocks.HR, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/((?:^\s*)(?:[*+-]\s))/m)) {
    // * item
    // + item
    // - item
    return (0, _list2.default)(options.listOption, currentTextNode, matched, change, false);
  } else if (matched = currentLineText.match(/((?:^\s*)(?:\d+\.\s))/m)) {
    // 1. item
    return (0, _list2.default)(options.listOption, currentTextNode, matched, change, true);
  }

  var offsetBeforeSpace = value.selection.anchorOffset - 2;
  var lastChar = currentLineText.charAt(offsetBeforeSpace);
  var prevTextFromSpace = currentLineText.substr(0, offsetBeforeSpace + 1); // inline patterns

  if (matched = lastChar === "`" && prevTextFromSpace.match(/\s?(`|``)((?!\1).)+?\1$/m)) {
    // [Code] `code`
    return (0, _code.default)(options.marks.CODE, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/!\[([^\]]+)\]\(([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?)\)/)) {
    // ![example](http://example.com "Optional title")
    return (0, _image.default)(options.inlines.IMAGE, currentTextNode, matched, change);
  } else if (matched = currentLineText.match(/\[([^\]]+)\]\(([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?)\)/)) {
    // [example](http://example.com "Optional title")
    return (0, _link.default)(options.inlines.LINK, currentTextNode, matched, change);
  }

  if (lastChar === "*" || lastChar === "_") {
    if (matched = prevTextFromSpace.match(/\s?(\*\*\*|___)((?!\1).)+?\1$/m)) {
      // [Bold + Italic] ***[strong + italic]***, ___[strong + italic]___
      return (0, _boldItalic.default)(options.marks, currentTextNode, matched, change);
    } else if (matched = prevTextFromSpace.match(/\s?(\*\*|__)((?!\1).)+?\1$/m)) {
      // [Bold] **strong**, __strong__
      return (0, _bold.default)(options.marks.BOLD, currentTextNode, matched, change);
    } else if (matched = prevTextFromSpace.match(/\s?(\*|_)((?!\1).)+?\1$/m)) {
      // [Italic] _em_, *em*
      return (0, _italic.default)(options.marks.ITALIC, currentTextNode, matched, change);
    }
  }

  if (lastChar === "~") {
    if (matched = prevTextFromSpace.match(/\s?(~)((?!\1).)+?\1$/m)) {
      // [Strike Through] ~strikethrough~
      return (0, _strikethrough.default)(options.marks.STRIKETHROUGH, currentTextNode, matched, change);
    }
  }
};

var _default = function _default() {
  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = {
    blocks: Object.assign(_blocks.default, opt.blocks),
    marks: Object.assign(_marks.default, opt.marks),
    inlines: Object.assign(_inlines.default, opt.inlines),
    codeOption: Object.assign({
      onlyIn: function onlyIn(node) {
        return node.type === _blocks.default.CODE;
      }
    }, opt.codeOption),
    blockquoteOption: Object.assign({}, opt.blockquoteOption),
    listOption: Object.assign(_list.default, opt.listOption)
  };
  return {
    onKeyDown: function onKeyDown(e, change) {
      switch (e.key) {
        case _keys.KEY_ENTER:
          return (0, _onEnter.default)(options, change);
      }
    },
    onKeyUp: function onKeyUp(e, change) {
      switch (e.key) {
        case _keys.KEY_SPACE:
          return checkPatterns(options, change);
      }
    }
  };
};

exports.default = _default;