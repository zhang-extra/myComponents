{"version":3,"file":"rehook.umd.js","sources":["../src/rehook/branch.js","../src/rehook/rename-prop.js","../src/rehook/with-props-on-change.js","../src/rehook/catch-render.js","../src/rehook/default-props.js","../src/rehook/flatten-prop.js","../src/rehook/lifecycle.js","../src/rehook/map-props.js","../src/rehook/namespace.js","../src/rehook/pipe.js","../src/rehook/rename-props.js","../src/rehook/render-component.js","../src/rehook/render-nothing.js","../src/rehook/with-handlers.js","../src/rehook/with-props.js","../src/rehook/with-reducer.js","../src/rehook/with-state-handlers.js","../src/rehook/with-state.js"],"sourcesContent":["import React from 'react'\n// @ts-ignore\nconst { useMemo } = React\n\n// Note, branching disobeys one of the hook rules because\n// it wraps hooks in a condition. For this reason, the branch\n// is cached and kept the same regardless of updates.\n\n/**\n *\n * @param {Function} condition\n * @param {Function} left\n * @param {Function} right\n * @returns {Function}\n */\nconst branch = (condition, left, right = x => x) => (props = {}) => {\n  const conditionResult = useMemo(() => condition(props), [])\n\n  return conditionResult ? left(props) : right(props)\n}\n\nexport default branch\n","/**\n * @param {string|symbol} a\n * @param {string|symbol} b\n * @returns {Object}\n */\nconst renameProp = (a, b) => ({ [a]: prop, ...props } = {}) => ({\n  ...props,\n  [b]: prop,\n})\n\nexport default renameProp\n","import React from 'react'\n// @ts-ignore\nconst { useMemo, useRef, useEffect } = React\n\nfunction usePrevious(value) {\n  const ref = useRef()\n\n  useEffect(() => {\n    ref.current = value\n  })\n\n  return ref.current\n}\n\n/**\n *\n * @param {any} shouldMapOrKeys\n * @param {Function} createProps\n * @returns {Object}\n */\nconst withPropsOnChange = (shouldMapOrKeys, createProps) => (props = {}) => {\n  const previousProps = usePrevious(props)\n\n  const keys = Array.isArray(shouldMapOrKeys)\n    ? shouldMapOrKeys.map(key => props[key])\n    : shouldMapOrKeys(props, previousProps)\n      ? undefined\n      : []\n\n  const mappedProps = useMemo(() => createProps(props), keys)\n\n  return {\n    ...props,\n    ...mappedProps,\n  }\n}\n\nexport default withPropsOnChange\n","import React from 'react'\n\n/**\n * @param {Function} component\n * @returns {Object}\n */\nconst catchRender = component => {\n  const newComponent = (props = {}) => {\n    let result = null\n\n    try {\n      result = component(props)\n    } catch (e) {\n      if (typeof e !== 'object' || React.isValidElement(e)) result = e\n      else throw e\n    }\n\n    return result\n  }\n\n  newComponent.displayName =\n    component.displayName || component.name || 'Component'\n\n  return newComponent\n}\n\nexport default catchRender\n","/**\n * @param {Object} defaultProps\n * @returns {Object}\n */\nconst defaultProps = defaultProps => (props = {}) => ({\n  ...defaultProps,\n  ...props,\n})\n\nexport default defaultProps\n","/**\n * @param {string|symbol} propName\n * @returns {Object}\n */\nconst flattenProp = propName => (props = {}) => ({\n  ...props,\n  ...props[propName],\n})\n\nexport default flattenProp\n","import React from 'react'\n// @ts-ignore\nconst { useEffect, useRef, useState } = React\n\nfunction usePrevious(value) {\n  const ref = useRef()\n\n  useEffect(() => {\n    ref.current = value\n  })\n\n  return ref.current\n}\n\n/**\n * @param {Object} spec\n * @returns {Object}\n */\nconst lifecycle = spec => (props = {}) => {\n  const [state, setStateRaw] = useState({})\n  const setState = update => {\n    setStateRaw({\n      ...state,\n      ...(typeof update === 'function' ? update(state) : update),\n    })\n  }\n\n  const self = { props, state, setState }\n\n  if (spec.componentDidMount) {\n    useEffect(() => {\n      spec.componentDidMount.call(self)\n    }, [])\n  }\n\n  if (spec.componentWillUnmount) {\n    useEffect(() => {\n      return () => {\n        spec.componentWillUnmount.call(self)\n      }\n    }, [])\n  }\n\n  if (spec.componentDidUpdate) {\n    const previousProps = usePrevious(props)\n    useEffect(() => {\n      spec.componentDidUpdate.call(self, previousProps, null, null)\n    })\n  }\n\n  return { ...props, ...state }\n}\n\nexport default lifecycle\n","/**\n * @param {Function} fn\n * @returns {Object}\n */\nconst mapProps = fn => (props = {}) => fn(props)\n\nexport default mapProps\n","/**\n * @param {string|symbol} propName\n * @param {Function} enhance\n * @returns {Object}\n */\nconst namespace = (propName, enhance) => (props = {}) => ({\n  ...props,\n  [propName]: enhance(props)(),\n})\n\nexport default namespace\n","/**\n * @param  {...Function} fns\n * @returns {Object}\n */\nconst pipe = (...fns) => (props = {}) => fns.reduce((v, f) => f(v), props)\n\nexport default pipe\n","/**\n * @param {Object} propMap\n * @returns {Object}\n */\nconst renameProps = propMap => (props = {}) => ({\n  // Remove renamed props\n  ...Object.entries(props)\n    .filter(([key]) => !(key in propMap))\n    .reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}),\n  // Rename props\n  ...Object.entries(propMap)\n    .map(([oldName, newName]) => [newName, props[oldName]])\n    .reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}),\n})\n\nexport default renameProps\n","/**\n * @param {any} comp\n * @returns {Object}\n */\nconst renderComponent = comp => (props = {}) => {\n  throw comp(props)\n}\n\nexport default renderComponent\n","/**\n * @returns {Object}\n */\nconst renderNothing = (/* props */) => {\n  // eslint-disable-next-line\n  throw null;\n}\n\nexport default renderNothing\n","import React from 'react'\n// @ts-ignore\nconst { useMemo } = React\n\n/**\n *\n * @param {Object} handlers\n * @returns {Object}\n */\nconst withHandlers = handlers => (props = {}) => {\n  const realHandlers = useMemo(\n    () => (typeof handlers === 'function' ? handlers(props) : handlers),\n    []\n  )\n\n  const actionTypes = Object.keys(realHandlers)\n\n  const boundHandlers = actionTypes.reduce(\n    (obj, type) =>\n      Object.assign(obj, {\n        [type]: payload => realHandlers[type](props)(payload),\n      }),\n    {}\n  )\n\n  return { ...props, ...boundHandlers }\n}\n\nexport default withHandlers\n","/**\n *\n * @param {Function|Object} fn\n */\nconst withProps = fn => (props = {}) => ({\n  ...props,\n  ...(typeof fn === 'function' ? fn(props) : fn),\n})\n\nexport default withProps\n","import React from 'react'\n// @ts-ignore\nconst { useReducer, useMemo } = React\n\n/**\n *\n * @param {string|symbol} stateName\n * @param {string|symbol} dispatchName\n * @param {Function} reducer\n * @param {any} initialValue\n */\nconst withReducer = (\n  stateName,\n  dispatchName,\n  reducer,\n  initialValue\n) => props => {\n  const [state, dispatch] = useReducer(\n    reducer,\n    typeof initialValue === 'function'\n      ? useMemo(() => initialValue(props), [])\n      : initialValue\n  )\n\n  return { ...props, [stateName]: state, [dispatchName]: dispatch }\n}\n\nexport default withReducer\n","import React from 'react'\n// @ts-ignore\nconst { useReducer, useMemo } = React\n\n/**\n *\n * @param {any} initialValue\n * @param {Object} handlers\n * @returns {Object}\n */\nconst withStateHandlers = (initialValue, handlers) => (props = {}) => {\n  const actionTypes = Object.keys(handlers)\n\n  const reducer = (state, action) => {\n    return { ...state, ...handlers[action.type](state, props)(action.payload) }\n  }\n\n  const [state, dispatch] = useReducer(\n    reducer,\n    typeof initialValue === 'function'\n      ? useMemo(() => initialValue(props), [])\n      : initialValue\n  )\n\n  const boundHandlers = actionTypes.reduce(\n    (obj, type) =>\n      Object.assign(obj, {\n        [type]: payload => {\n          if (payload !== undefined) dispatch({ type, payload })\n        },\n      }),\n    {}\n  )\n\n  return { ...props, ...state, ...boundHandlers }\n}\n\nexport default withStateHandlers\n","import React from 'react'\n// @ts-ignore\nconst { useState, useMemo } = React\n\n/**\n *\n * @param {string|symbol} stateName\n * @param {string|symbol} stateUpdaterName\n * @param {any} initialState\n */\nconst withState = (stateName, stateUpdaterName, initialState) => (\n  props = {}\n) => {\n  const [state, update] = useState(\n    typeof initialState === 'function'\n      ? useMemo(() => initialState(props), [])\n      : initialState\n  )\n\n  return {\n    ...props,\n    [stateName]: state,\n    [stateUpdaterName]: update,\n  }\n}\n\nexport default withState\n"],"names":["const","condition","left","right","x","props","useMemo","component","newComponent","let","result","e","React","isValidElement","displayName","name","defaultProps","Object","propName","spec","useState","self","state","update","setStateRaw","componentDidMount","useEffect","call","componentWillUnmount","componentDidUpdate","previousProps","value","ref","useRef","current","usePrevious","fn","enhance","fns","reduce","v","f","a","b","prop","propMap","entries","filter","obj","assign","map","comp","handlers","realHandlers","boundHandlers","keys","type","payload","shouldMapOrKeys","createProps","Array","isArray","key","undefined","mappedProps","stateName","dispatchName","reducer","initialValue","useReducer","dispatch","actionTypes","action","stateUpdaterName","initialState"],"mappings":"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"}