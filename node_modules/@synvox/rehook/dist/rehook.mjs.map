{"version":3,"file":"rehook.mjs","sources":["../src/rehook/branch.js","../src/rehook/catch-render.js","../src/rehook/default-props.js","../src/rehook/flatten-prop.js","../src/rehook/lifecycle.js","../src/rehook/map-props.js","../src/rehook/namespace.js","../src/rehook/pipe.js","../src/rehook/rename-prop.js","../src/rehook/rename-props.js","../src/rehook/render-component.js","../src/rehook/render-nothing.js","../src/rehook/with-handlers.js","../src/rehook/with-props-on-change.js","../src/rehook/with-props.js","../src/rehook/with-reducer.js","../src/rehook/with-state-handlers.js","../src/rehook/with-state.js"],"sourcesContent":["import React from 'react'\n// @ts-ignore\nconst { useMemo } = React\n\n// Note, branching disobeys one of the hook rules because\n// it wraps hooks in a condition. For this reason, the branch\n// is cached and kept the same regardless of updates.\n\n/**\n *\n * @param {Function} condition\n * @param {Function} left\n * @param {Function} right\n * @returns {Function}\n */\nconst branch = (condition, left, right = x => x) => (props = {}) => {\n  const conditionResult = useMemo(() => condition(props), [])\n\n  return conditionResult ? left(props) : right(props)\n}\n\nexport default branch\n","import React from 'react'\n\n/**\n * @param {Function} component\n * @returns {Object}\n */\nconst catchRender = component => {\n  const newComponent = (props = {}) => {\n    let result = null\n\n    try {\n      result = component(props)\n    } catch (e) {\n      if (typeof e !== 'object' || React.isValidElement(e)) result = e\n      else throw e\n    }\n\n    return result\n  }\n\n  newComponent.displayName =\n    component.displayName || component.name || 'Component'\n\n  return newComponent\n}\n\nexport default catchRender\n","/**\n * @param {Object} defaultProps\n * @returns {Object}\n */\nconst defaultProps = defaultProps => (props = {}) => ({\n  ...defaultProps,\n  ...props,\n})\n\nexport default defaultProps\n","/**\n * @param {string|symbol} propName\n * @returns {Object}\n */\nconst flattenProp = propName => (props = {}) => ({\n  ...props,\n  ...props[propName],\n})\n\nexport default flattenProp\n","import React from 'react'\n// @ts-ignore\nconst { useEffect, useRef, useState } = React\n\nfunction usePrevious(value) {\n  const ref = useRef()\n\n  useEffect(() => {\n    ref.current = value\n  })\n\n  return ref.current\n}\n\n/**\n * @param {Object} spec\n * @returns {Object}\n */\nconst lifecycle = spec => (props = {}) => {\n  const [state, setStateRaw] = useState({})\n  const setState = update => {\n    setStateRaw({\n      ...state,\n      ...(typeof update === 'function' ? update(state) : update),\n    })\n  }\n\n  const self = { props, state, setState }\n\n  if (spec.componentDidMount) {\n    useEffect(() => {\n      spec.componentDidMount.call(self)\n    }, [])\n  }\n\n  if (spec.componentWillUnmount) {\n    useEffect(() => {\n      return () => {\n        spec.componentWillUnmount.call(self)\n      }\n    }, [])\n  }\n\n  if (spec.componentDidUpdate) {\n    const previousProps = usePrevious(props)\n    useEffect(() => {\n      spec.componentDidUpdate.call(self, previousProps, null, null)\n    })\n  }\n\n  return { ...props, ...state }\n}\n\nexport default lifecycle\n","/**\n * @param {Function} fn\n * @returns {Object}\n */\nconst mapProps = fn => (props = {}) => fn(props)\n\nexport default mapProps\n","/**\n * @param {string|symbol} propName\n * @param {Function} enhance\n * @returns {Object}\n */\nconst namespace = (propName, enhance) => (props = {}) => ({\n  ...props,\n  [propName]: enhance(props)(),\n})\n\nexport default namespace\n","/**\n * @param  {...Function} fns\n * @returns {Object}\n */\nconst pipe = (...fns) => (props = {}) => fns.reduce((v, f) => f(v), props)\n\nexport default pipe\n","/**\n * @param {string|symbol} a\n * @param {string|symbol} b\n * @returns {Object}\n */\nconst renameProp = (a, b) => ({ [a]: prop, ...props } = {}) => ({\n  ...props,\n  [b]: prop,\n})\n\nexport default renameProp\n","/**\n * @param {Object} propMap\n * @returns {Object}\n */\nconst renameProps = propMap => (props = {}) => ({\n  // Remove renamed props\n  ...Object.entries(props)\n    .filter(([key]) => !(key in propMap))\n    .reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}),\n  // Rename props\n  ...Object.entries(propMap)\n    .map(([oldName, newName]) => [newName, props[oldName]])\n    .reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}),\n})\n\nexport default renameProps\n","/**\n * @param {any} comp\n * @returns {Object}\n */\nconst renderComponent = comp => (props = {}) => {\n  throw comp(props)\n}\n\nexport default renderComponent\n","/**\n * @returns {Object}\n */\nconst renderNothing = (/* props */) => {\n  // eslint-disable-next-line\n  throw null;\n}\n\nexport default renderNothing\n","import React from 'react'\n// @ts-ignore\nconst { useMemo } = React\n\n/**\n *\n * @param {Object} handlers\n * @returns {Object}\n */\nconst withHandlers = handlers => (props = {}) => {\n  const realHandlers = useMemo(\n    () => (typeof handlers === 'function' ? handlers(props) : handlers),\n    []\n  )\n\n  const actionTypes = Object.keys(realHandlers)\n\n  const boundHandlers = actionTypes.reduce(\n    (obj, type) =>\n      Object.assign(obj, {\n        [type]: payload => realHandlers[type](props)(payload),\n      }),\n    {}\n  )\n\n  return { ...props, ...boundHandlers }\n}\n\nexport default withHandlers\n","import React from 'react'\n// @ts-ignore\nconst { useMemo, useRef, useEffect } = React\n\nfunction usePrevious(value) {\n  const ref = useRef()\n\n  useEffect(() => {\n    ref.current = value\n  })\n\n  return ref.current\n}\n\n/**\n *\n * @param {any} shouldMapOrKeys\n * @param {Function} createProps\n * @returns {Object}\n */\nconst withPropsOnChange = (shouldMapOrKeys, createProps) => (props = {}) => {\n  const previousProps = usePrevious(props)\n\n  const keys = Array.isArray(shouldMapOrKeys)\n    ? shouldMapOrKeys.map(key => props[key])\n    : shouldMapOrKeys(props, previousProps)\n      ? undefined\n      : []\n\n  const mappedProps = useMemo(() => createProps(props), keys)\n\n  return {\n    ...props,\n    ...mappedProps,\n  }\n}\n\nexport default withPropsOnChange\n","/**\n *\n * @param {Function|Object} fn\n */\nconst withProps = fn => (props = {}) => ({\n  ...props,\n  ...(typeof fn === 'function' ? fn(props) : fn),\n})\n\nexport default withProps\n","import React from 'react'\n// @ts-ignore\nconst { useReducer, useMemo } = React\n\n/**\n *\n * @param {string|symbol} stateName\n * @param {string|symbol} dispatchName\n * @param {Function} reducer\n * @param {any} initialValue\n */\nconst withReducer = (\n  stateName,\n  dispatchName,\n  reducer,\n  initialValue\n) => props => {\n  const [state, dispatch] = useReducer(\n    reducer,\n    typeof initialValue === 'function'\n      ? useMemo(() => initialValue(props), [])\n      : initialValue\n  )\n\n  return { ...props, [stateName]: state, [dispatchName]: dispatch }\n}\n\nexport default withReducer\n","import React from 'react'\n// @ts-ignore\nconst { useReducer, useMemo } = React\n\n/**\n *\n * @param {any} initialValue\n * @param {Object} handlers\n * @returns {Object}\n */\nconst withStateHandlers = (initialValue, handlers) => (props = {}) => {\n  const actionTypes = Object.keys(handlers)\n\n  const reducer = (state, action) => {\n    return { ...state, ...handlers[action.type](state, props)(action.payload) }\n  }\n\n  const [state, dispatch] = useReducer(\n    reducer,\n    typeof initialValue === 'function'\n      ? useMemo(() => initialValue(props), [])\n      : initialValue\n  )\n\n  const boundHandlers = actionTypes.reduce(\n    (obj, type) =>\n      Object.assign(obj, {\n        [type]: payload => {\n          if (payload !== undefined) dispatch({ type, payload })\n        },\n      }),\n    {}\n  )\n\n  return { ...props, ...state, ...boundHandlers }\n}\n\nexport default withStateHandlers\n","import React from 'react'\n// @ts-ignore\nconst { useState, useMemo } = React\n\n/**\n *\n * @param {string|symbol} stateName\n * @param {string|symbol} stateUpdaterName\n * @param {any} initialState\n */\nconst withState = (stateName, stateUpdaterName, initialState) => (\n  props = {}\n) => {\n  const [state, update] = useState(\n    typeof initialState === 'function'\n      ? useMemo(() => initialState(props), [])\n      : initialState\n  )\n\n  return {\n    ...props,\n    [stateName]: state,\n    [stateUpdaterName]: update,\n  }\n}\n\nexport default withState\n"],"names":["branch","condition","left","right","x","props","useMemo","catchRender","component","const","newComponent","let","result","e","React","isValidElement","displayName","name","defaultProps","Object","flattenProp","propName","lifecycle","spec","useState","self","state","update","setStateRaw","componentDidMount","useEffect","call","componentWillUnmount","componentDidUpdate","previousProps","value","ref","useRef","current","usePrevious","mapProps","fn","namespace","enhance","pipe","fns","reduce","v","f","renameProp","a","b","prop","renameProps","propMap","entries","filter","obj","assign","map","renderComponent","comp","renderNothing","withHandlers","handlers","realHandlers","boundHandlers","keys","type","payload","withPropsOnChange","shouldMapOrKeys","createProps","Array","isArray","key","undefined","mappedProps","withProps","withReducer","stateName","dispatchName","reducer","initialValue","useReducer","dispatch","withStateHandlers","actionTypes","action","withState","stateUpdaterName","initialState"],"mappings":"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"}